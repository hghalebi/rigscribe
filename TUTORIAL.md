# Getting Started with RigScribe: Automated Prompt Engineering in Rust

Welcome to the **RigScribe** tutorial! This guide will teach you how to use RigScribe to automate the creation of high-quality system prompts for your AI applications using Rust and the [Rig Framework](https://github.com/0xPlaygrounds/rig).

## Table of Contents
1. [Introduction](#1-introduction)
2. [Prerequisites](#2-prerequisites)
3. [Core Concepts](#3-core-concepts)
4. [Step-by-Step Implementation](#4-step-by-step-implementation)
5. [Understanding the "Refinery"](#5-understanding-the-refinery)
6. [Advanced Usage](#6-advanced-usage)

---

## 1. Introduction

**RigScribe** treats prompts as software assets. Instead of guessing and hand-tuning text ("prompt engineering"), you use RigScribe to programmatically generate robust system prompts from simple human instructions.

It uses a "Swarm" of agents to:
1. **Deconstruct** your request.
2. **Research** best practices.
3. **Refine** the output into a professional specification.

## 2. Prerequisites

Before you begin, ensure you have:

*   **Rust installed**: `cargo --version` should return 1.75+.
*   **Gemini API Key**: RigScribe uses Google's Gemini models. You need an API key exported in your environment.

```bash
export GEMINI_API_KEY="your_api_key_here"
```

## 3. Core Concepts

### Intent vs. Artifact
*   **Intent**: Your raw, vague request (e.g., "Make a python snake game").
*   **Artifact**: The polished, professional system prompt generated by RigScribe.

### ScopeId & Caching
RigScribe is designed for production. You don't want to re-generate (and pay for) the same prompt every time your app starts.
*   **ScopeId**: A unique identifier (integer) for a specific prompt logic.
*   **Caching**: RigScribe checks a local folder for an existing `Artifact` matching the `ScopeId`. If found, it loads it instantly.

---

## 4. Step-by-Step Implementation

Let's build a simple tool that generates a system prompt for a "CLI Tool Assistant".

### Step 1: Add Dependency

Add `rigscribe` to your `Cargo.toml`.

```toml
[dependencies]
rigscribe = "0.1.4"
tokio = { version = "1.0", features = ["full"] }
```

### Step 2: Write the Code

Create a `src/main.rs` file:

```rust
use rigscribe::{RigScribe, ScopeId, Result};
use std::env;

#[tokio::main]
async fn main() -> Result<()> {
    // 1. Initialize RigScribe with a cache directory
    // This folder will store your optimized prompts as JSON files.
    let scribe = RigScribe::new("./.prompts_cache");

    // 2. Define your Intent
    let raw_request = "I want an AI assistant that helps users write Clap CLI tools in Rust.";
    
    // 3. Define a stable ScopeId
    // This ID (e.g., 101) represents this specific "CLI Assistant" feature.
    let feature_id = ScopeId(101);

    println!("Refining prompt for: '{}'...", raw_request);

    // 4. Optimize (or load from cache)
    // The first run will take a few seconds to 'think'.
    // Subsequent runs will be instant.
    let artifact = scribe.optimize_with_cache(raw_request, feature_id).await?;

    println!("\n--- Optimized System Prompt ---\n");
    println!("{}", artifact.system_prompt);
    
    Ok(())
}
```

### Step 3: Run It

```bash
cargo run
```

**First Run Output:**
You will see the agent "thinking" (streaming output) as it analyzes your request, consults its internal tools, and writes the prompt.

**Second Run Output:**
It will immediately print "Cache HIT" and display the prompt without calling the AI.

---

## 5. Understanding the "Refinery"

When you call `optimize_with_cache` (on a cache miss), RigScribe triggers the **Optimizer Agent**. This agent follows a strict workflow:

1.  **Deconstructor Tool**: Breaks down your request ("Make a CLI assistant") into technical requirements (Rust, Clap crate, Error handling patterns).
2.  **WebSearcher Tool**: If the agent needs latest docs (e.g., "latest Clap v4 features"), it searches the web.
3.  **PromptReviewer Tool**: Validates the draft against known best practices for System Prompts (clarity, constraints, few-shot examples).

This process ensures the final `Artifact` is far superior to a zero-shot attempt.

---

## 6. Advanced Usage

### Bypassing Cache
If you are experimenting and always want a fresh generation, use `optimize_agentic` directly:

```rust
use rigscribe::RigScribe;

let artifact = RigScribe::optimize_agentic("Explain Quantum Physics like a pirate").await?;
```

### Custom Cache Directory
You can organize prompts by environment:

```rust
let cache_dir = if cfg!(debug_assertions) {
    "./cache/dev"
} else {
    "/var/data/prompts/prod"
};
let scribe = RigScribe::new(cache_dir);
```

---

## Summary

RigScribe allows you to:
1.  **Formalize** your prompts as code (`ScopeId`).
2.  **Automate** the quality assurance of those prompts (The Agentic Refinery).
3.  **Deploy** reliably with built-in caching.

Start treating your prompts like the software they are!

